
# React Common Hooks

除了 `useState`，React 还提供了许多其他的 Hooks 用于管理组件的状态和生命周期。以下是一些常见的 Hooks，以及它们的详细解释和示例代码。

## 1. useState
**用途**：`useState` 用于在函数组件中添加本地状态。这个状态在组件的多次渲染之间是被保持的,它返回一个状态变量和一个更新这个状态变量的函数。

### 基本用法
- `useState` 接受初始状态作为参数，并返回一个包含两个元素的数组。
- 第一个元素是当前的状态值，第二个元素是一个允许你更新该状态的函数。

### 特点
- 使用 `useState`，你可以在函数组件中添加和读取状态，而无需将组件转换为类。
- 状态的更新可能是异步的，React 可能会延迟或合并多次 `setState()` 调用以优化性能。

**示例代码**：

```jsx
import React, { useState } from 'react';

function Example() {
  // 声明一个新的状态变量，我们将其称为 "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

## 2. useEffect

**用途**：用于在组件渲染到屏幕之后执行副作用操作（如数据获取、订阅或手动更改 React 组件中的 DOM）。

**示例代码**：

```jsx
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

## 3. useContext

**用途**：允许你在组件树中共享数据而不必显式地通过每个层级传递 props。

**示例代码**：

```jsx
import React, { useContext } from 'react';

const MyContext = React.createContext();

function Example() {
  const value = useContext(MyContext);
  return <div>{value}</div>;
}
```

## 4. useReducer

**用途**：用于更复杂的组件状态逻辑，它接受一个状态更新的函数和初始状态，返回当前的状态和一个让你能够触发状态更新的 dispatch 方法。

**示例代码**：

```jsx
import React, { useReducer } from 'react';

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
    </>
  );
}
```

## 5. useRef

**用途**：用于获取对 DOM 元素的直接访问，或者存储任何可变值，该值不会导致组件重新渲染。

**示例代码**：

```jsx
import React, { useRef } from 'react';

function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  the onButtonClick = () => {
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus the input</button>
    </>
  );
}
```

## 6. useMemo

**用途**：用于优化性能，它可以记住一个计算得出的值，并且只有在其依赖项改变时才重新计算。

**示例代码**：

```jsx
import React, { useMemo } from 'react';

function Example({ a, b }) {
  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
  return <div>{memoizedValue}</div>;
}
```

## 7. useCallback

**用途**：返回一个记忆化的回调函数，该回调函数仅在某个依赖项改变时才会更新。

**示例代码**：

```jsx
import React, { useCallback } from 'react';

function Example({ onIncrement }) {
  const memoizedCallback = useCallback(
    () => {
      onIncrement();
    },
    [onIncrement],
  );
  return <button onClick={memoizedCallback}>Increment</button>;
}
```
