### 1.使用弹出框组件时

**场景**：当在页面中给 meesgae 弹出框传入某变量 id，然后弹出框 message 通过 id 去发起请求渲染数据<br />那么当我关闭弹出框，然后再打开弹出框的时候里面的打印函数没有了呢<br />**分析**：因为再我关闭弹出框的时候我并没有清空内部的属性，弹出框它只不过是显示与隐藏罢了，所以不会重新执行渲染函数，那就更不会打印内部的值了，<br />**解决办法** 再关闭弹出框的时候清空内部的数据。比如在当前页面去侦听传入显示隐藏的变量，然后当我们关闭的时候去清空传入的 id 即可

<a name="H5sOB"></a>

### 2.前置导航守卫

**1.在前置导航守卫中使用了 addRoute 动态添加路由后，为什么必须紧跟着执行 return next(to.path) ？ \_**<br />在前置导航守卫中使用 addRoute 动态添加路由时，需要在添加完成之后调用 next()函数来让导航继续进行。在调用 next()函数之前，可以选择传递一个路由路径作为参数，用来指示导航要前往的下一个路由。<br />**如果在 addRoute 之后，直接调用 next()函数，那么导航会继续前往当前的路由，而不会考虑动态添加的路由。为了让导航考虑动态添加的路由，需要将新添加的路由的路径作为参数传递给 next()函数。这样，导航就会使用新添加的路由进行跳转。**<br />因此，在使用 addRoute 动态添加路由后，需要在前置导航守卫中返回 next(to.path)，其中 to.path 表示要前往的路由路径，以确保导航可以使用新添加的路由进行跳转。

**2.那为什么要 return next(to.path) 直接 next(to.path)不可以呢？**<br />在前置导航守卫中，如果你希望在使用 addRoute 动态添加路由后立即完成导航并且使用新添加的路由进行跳转，你可以直接调用 next(to.path)，这样导航会使用指定的路由路径进行跳转。<br />**然而，如果你在前置导航守卫中使用了异步操作，比如在从服务器获取路由信息时，你需要等待异步操作完成后才能调用 next()函数。在这种情况下，如果没有使用 return 语句来将 next(to.path)返回给导航守卫的调用者，那么导航将在等待异步操作完成之前继续进行。这可能会导致一些意外的行为，例如导航到错误的路由或者在动态添加路由之前执行其他的导航守卫**。<br />**使用 return 语句可以确保导航守卫的调用者等待异步操作完成并且得到正确的 next()函数调用，以便在新添加的路由准备就绪后立即完成导航并且使用新添加的路由进行跳转。因此，在使用 addRoute 动态添加路由时，建议使用 return next(to.path)来确保正确的导航行为**

<a name="vIOYV"></a>

### 3.在后台管理系统中，在前置导航守卫中动态添加路由规则之后为什么退出登录后切换不同身份的用户，当进入主页面后，页面还是之前的路由页面，解决需要手动刷新呢？

因为在我们配置动态路由之后，当我们点击退出登录的时候，路由表还是原来的路由表，我们并未将上次动态添加的路由给清除掉，<br />解决办法，在退出登录时，清理当前用户添加的动态路由即可
